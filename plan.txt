The project is going to be divided into 5 sub parts.
There will be unit test for 3 of the 5 sub parts.

Project sub-parts:

1. Room: A knowledge container to implement the concept of a single room in a world's grid.
It will be implemented as a c++ class and will have:
    - a private attribute,
    - constructor and
    - two accessor methods

Knowledge will be represented using knowledge terms given during the tutorial session.
They are:
        Pit => true if there is pit in the room.
        Breeze => true if there is breeze in the room.
        Wumpus => true if there is wumpus in the room.
        Stench => true if the room stenchs.
        Visited => true if the room is already visited.
        Glitter => true if there is gold in the room.

- The constructor has no input parameter. It will initialize all the 6 knowledge terms to false(assuming
  "false" is default value).

- The attribute is going to be implemented using c++ map datastructure. Knowledge terms will be used as key
  and corresponding truth-values(boolean) will be used as value in the map.

- The accessor method is a getter that will take knowledge term as an argument and use it as key to return
  the truth value of the knowledge term from the private map attribute.

- The second accesor method will return list of valid adjacent rooms.

2. World: The actual game world. It will contain the environment and all the components that will build up
   the game world.
   It will be implemented as a c++ class and will have:

   Attributes:
        - model
        - grid
        - agent_status
        - wumpus_status

    Attributes description:
        model:
            Holds every statment of the world's model in a logical
            syllogism format (how?).
            There will be five statments as given in during the tutorial session.
            It has to have a way to access premis and conclusion of every statment.

        grid:
            A 4X4 grid of room objects. Can be implemented using 2D array of room objects.
            
        agent_status:
            Holds the agent's remaining_arrow, living, current_room_id and 
            found_gold information.
            Can be implemented using c++ map.
            e.g: map<string, int, string, bool, string, pair<int>, string, bool>

        wumpus_status:
            Holds the wumpus' living and room_id.
            Can be implemented using c++ map.
            e.g: map<string, bool, string, pair<int>>

    Accessors:
        - grid_init()
        - get_model()
        - get_grid()
        - get_room(room_id)
        - get_agent_status()
        - get_wumpus_status()
        - kill_wumpus_at(room_id)

    Accessors description:
        grid_init():
            Initialize the grid with random knowledge set to the rooms.
            It has to place the wumpus, the 3 pits and the gold at randomly selected rooms.
            Then it will set truth values to the other rooms based on the random setup.
            It will place the agent at room (1,1).

        get_model():
            Returns copy of the model attribute.

        get_grid():
            Return copy of the grid attribute. But, it first checks
            the type of the object calling this function. It only 
            responds to calls from the user interface object and have
            to deny calls made from the agent object.

        get_room(room_id):
            Return copy of the room object at the given room_id from the grid.
            It's assumed that the agent calls this function after it moved to
            the room with the specified room_id. So, this function will also
            set the current room value of the agent_status attribute to room_id.

        get_agent_status():
            Return copy of the agent_status attribute.
            It will be used by the user interface object.
            Note: the function doesn't need to check the type of the caller since
            the information disclosed is not sensitive.

        get_wumpus_status():
            Return copy of the wumpus_status attribute.
            It will be used by the user interface object.
            Note: the function doesn't need to check the type of the caller since
            the information disclosed is not sensitive.

        kill_wumpus_at(room_id):
            Kills the wumpus if it is found in the given room_id and update wumpus_status
            and agent_status.
            Returns "true" if the wumpus is found and killed
                    "false" if the wumpus is not in the given room. 
            It will be used by the agent object.

            Killing is done based on this pseudocode:

                wumpus_room = grid.get_room(room_id) // get the room object at room_id
                
                // if there is wumpus in the room and the agent has arrow to use
                if(wumpus_room.get(wumpus) and agent_status.remaining_arrow>0) { 
                    wumpus_room.set(wumpus, false); // change the truth-value to "false"
                    wumpus_status.remaining_life = 0; // record that the wumpus is dead
                    agent_status.remaining_arrow--; // decrement the remaining_arrow

                    return true
                }
                
                else { // if there is no wumpus in the room
                    agent_status.remaining_arrow--; // decrement the remaining_arrow
                    return false
                }
 
3. Agent: The intelligent player that move around in the world to get the gold while
   escaping from being eaten by the wumpus and if possible kill it. In addition it will 
   also make decision to avoid falling into a pit.
   It will continiously move around in the world then deduce and fill in all the knowledge
   contained in the grid of the world in to it's own version of the grid until it finds
   the gold.

   It will be implemented as a c++ class and will have:

    Attributes:
        - model
        - grid
        - agent_status
        - perception_history
        - ok_rooms

    Attributes description:
        model:
            copy of the world's model attribute.

        grid:
            A 4X4 grid of room objects. Can be implemented using 2D array of room objects.
            It'll be filled in using the dicisions the agent make. And the aim is to fill it
            up with same knowledge as the grid of the world.
            
        agent_status:
            Holds the agent's remaining_arrow, living, current_room_id, facing_toward and
            found_gold information.
            Can be implemented using c++ map.
            e.g: map<string, int, string, bool, string, pair<int>,
                     string, string, string, bool>

        wumpus_status:
            Holds the wumpus' living and room_id.
            Can be implemented using c++ map.
            e.g: map<string, bool, string, pair<int>>

        perception_history:
            Holds all the percived information by the agent in a sequential order.
            Can be implemented using stack.

        ok_rooms:
            Queue of safe rooms to go to.
            Can be implemented using c++ queue. It is initialy filled with rooms of id
            (1,2) and (2,1) since they are the first possible and known safe rooms to 
            go to in the next step.

    Accessors:
        - get_perception_history()

    Accessors description:
        get_perception_history():
            Returns copy of the perception_history attribute.
        
    Sensors:
        - does_stench(room_id)
        - does_glitter(room_id)
        - has_breeze(room_id)
        - does_bump(room_id)
        - heared_scream()

    Sensors description:
        does_stench(room_id):
            Returns the truth-value of the "stench" knowledge term of the room at room_id in the grid.

        does_glitter(room_id):
            Returns the truth-value of the "Glitter" knowledge term of the room at room_id in the grid.

        has_breeze(room_id):
            Returns the truth-value of the "Breeze" knowledge term of the room at room_id in the grid.

        does_bump(room_id):
            Returns "true" if room_id is not a valid room id
            (i.e: let room_id = (x,y) 
                      room_id is valid if 0 < x < 5 and 0 < y < 5
                      room_id is invalid if x < 1 or x > 4 or y < 1 or y > 4)

        heared_scream():
            Returns "true" if wumpus is dead by checking the record in the wumpus_status attribute.

    Actuators:
        - go_to(room_id)
        - grab(room_id)
        - move_forward()
        - shoot(room_id)
        - turn_left()
        - turn_right()
    NOTE: grab(room_id), move_forward(), turn_left(), turn_right() might be redundant with go_to(room_id)

    Actuators description:
        go_to(room_id):
            Determine and execute sequence of actions inorder to go to the given room
            and then update states accordingly.

            It will update:
                - Truth-values of the rooms visited and their neighbours during execution
                  of the actions sequence.
                - agent_status and wumpus_status.

            (e.g.: [turn_left(), move_forward()] )

        grab(room_id):
            Determine sequence of actions to go to the given room where the gold is found in
            and update states accordingly.
            
            It will update:
                - Truth-values of the room the gold is found in.
                - agent_status.

            (e.g.: [turn_left(), move_forward()] )
            Note: the room as to be an adjecent room.
            
        move_forward():
            Move too the next room in the direction the agent is facing toward.
        
        shoot(room_id):
            Call the world.kill_wumpus_at(room_id) function and update states accordingly.

            It will update:
                - Truth-values of the room the wumpus was in and the neighbouring rooms.
                - agent_status and wumpus_status.

        turn_left():
            Change the facing_toward value of the agent_status one step in counter clockwise direction.

        turn_right():
            Change the facing_toward value of the agent_status one step in clockwise direction.

    Deduction components:
        - rule_match()        
        - program_evaluator(premises, conclusion)
        - play()

    Deduction components:
        rule_match():
            Return action commands based on what is percived about the world from
            current room.
            
            Implemented based on the pseudocode below:

                for (each adjacent room) {
                    if (wumpus is in the room) {
                        return shoot(room_id)
                    }

                    if (room glitters) {
                        return grab(room_id)
                    }

                    if (room is safe) {
                        ok_rooms.push(room)
                    }

                    return go_to(ok_rooms.pop())
                }

        program_evaluator(premises, conclusion):

        play():

4. UI: Terminal based user interface that display the simulated wumpus world game.
   The display includes the grid of the rooms at center, Agent perception history at
   right side, wumpus life status and agent status (life and remaining arrow) below
   rooms grid and current room info at left side.

   It will be implemented as a c++ class and will have:

    Constructor:
        - UI(world wumpusArena, agent AIplayer)
    
    Constructor description:
        UI(world wumpusArena, agent AIplayer): 
            Initializ UI with basic informations obtained from the parameters
            using their corresponding accessors to acess all the informations
            to be displayed.

    Method:
        - start_UI()

    Method description:
        start_UI():
            Initialize and update the user interface contents. The UI is Initialized
            in a separate thread so that the UI will be updated every time the agent
            performs an action using the signal sent by the agent after every action.

5. app: C++ executable file. All the above four components will be integrated and run
        from the main function of the source code c++ file.
    
    Steps:
      - Initialize a world instance.
      - Initialize an agent instance.
      - Initialize a UI instance using the world and agent instances initialized.
      - start the game.

Components relationship:
 1. World and Agent:
 2. World and UI:
 3. Agent and UI: